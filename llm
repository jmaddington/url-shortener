# URL Shortener with File Hosting

A simple URL shortener and file hosting service built with Flask, featuring SSO authentication and click tracking.

## Features

- Create custom short links for URLs
- Upload and host files with custom short links
- Copy short links to clipboard
- Admin interface for managing links
- File and URL deletion
- Click tracking with statistics
- Single Sign-On with Microsoft Entra ID
- Responsive design

## Setup

1. Install requirements:
```bash
pip install -r requirements.txt
```

2. Configure environment variables in `.env`:
```bash
# Create from .env.sample
cp .env.sample .env

# Edit .env with your settings
SECRET_KEY=your-secret-key
ENABLE_SSO=true  # or false for local auth
FLASK_DEBUG=false  # set to true for development
```

3. Run the application:
```bash
python app.py
```

4. Access the admin interface at:
```
http://localhost:8080/admin
```

## File Storage

- Uploaded files are stored in the `uploads/` directory
- Files are named as `{short_link}_{original_filename}`
- Database records in SQLite (`shortener.db`)
  - File metadata stored in `links` table
  - Click tracking in `clicks` table

## Database Schema

### Links Table
```sql
CREATE TABLE links (
    short_link TEXT PRIMARY KEY,
    target_url TEXT NOT NULL,
    is_file INTEGER NOT NULL DEFAULT 0,
    filename TEXT,
    created_by TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Clicks Table
```sql
CREATE TABLE clicks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    short_link TEXT NOT NULL,
    ip_address TEXT NOT NULL,
    user_agent TEXT,
    referer TEXT,
    clicked_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (short_link) REFERENCES links(short_link) ON DELETE CASCADE
);
```


## Docker Deployment

### Quick Start with Docker Compose

1. Run the setup script:
```bash
./setup.sh
```

2. Edit the `.env` file with your settings:
```bash
nano .env
```

3. Start the application:
```bash
docker-compose up -d
```

4. Access the admin interface at:
```
http://localhost:8080/admin
```

### Directory Structure

The setup creates the following directory structure:
```
.
├── data/           # SQLite database storage
├── uploads/        # Uploaded files storage
├── saml/          # SAML configuration
└── flask_session/ # Session data
```

### Docker Configuration

The Docker setup includes:
- Resource limits (1 CPU, 1GB RAM)
- Health checks
- Automatic restart
- Bind mounts for persistent data
- Non-root user execution
- Production-grade WSGI server (Gunicorn)

### Manual Docker Build

If you prefer to run without Docker Compose:

```bash
# Build the image
docker build -t urlshortener .

# Run the container
docker run -d \
  -p 8080:8080 \
  -v $(pwd)/data:/app/data \
  -v $(pwd)/uploads:/app/uploads \
  -v $(pwd)/saml:/app/saml \
  -v $(pwd)/flask_session:/app/flask_session \
  --env-file .env \
  --name urlshortener \
  urlshortener
```

### Container Management

```bash
# View logs
docker-compose logs -f

# Restart the application
docker-compose restart

# Stop the application
docker-compose down

# Update after code changes
docker-compose up -d --build
```

[Rest of previous content...]import glob
import zipfile
from flask import Flask, g, request, redirect, render_template, send_file, abort, session, url_for, make_response
from werkzeug.utils import secure_filename
from flask_session import Session
from urllib.parse import urlparse
import logging
import shutil
import os
import tempfile
import subprocess

from auth import requires_auth, init_saml_auth, prepare_flask_request
from database import init_db, get_db, close_db, record_click, get_link_stats
from config import Config

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)
app.config.from_object(Config)
Session(app)

# Initialize database
with app.app_context():
    init_db()

@app.route('/download-repo')
@requires_auth
def download_repo():
    # Create a temporary directory
    with tempfile.TemporaryDirectory() as temp_dir:
        # Create archive of the current directory, excluding certain paths
        repo_dir = os.getcwd()
        archive_path = os.path.join(temp_dir, 'urlshortener.zip')
        
        try:
            # Use git archive to create a zip of the repo
            subprocess.run([
                'git', 'archive', 
                '--format=zip',
                '--output', archive_path,
                'HEAD'
            ], check=True)
            
            return send_file(
                archive_path,
                as_attachment=True,
                download_name='urlshortener.zip',
                mimetype='application/zip'
            )
        except Exception as e:
            logger.error(f"Error creating repository archive: {str(e)}")
            return "Error creating repository archive", 500

@app.route('/sso/login')
def sso_login():
    req = prepare_flask_request(request)
    auth = init_saml_auth(req)
    return redirect(auth.login())

@app.route('/sso/metadata')
def metadata():
    req = prepare_flask_request(request)
    auth = init_saml_auth(req)
    settings = auth.get_settings()
    metadata = settings.get_sp_metadata()
    errors = settings.validate_metadata(metadata)

    if len(errors) == 0:
        resp = make_response(metadata, 200)
        resp.headers['Content-Type'] = 'text/xml'
    else:
        resp = make_response(', '.join(errors), 500)
    return resp

@app.route('/sso/acs', methods=['POST'])
def acs():
    req = prepare_flask_request(request)
    auth = init_saml_auth(req)
    
    logger.info("Processing SAML response")
    auth.process_response()
    errors = auth.get_errors()
    
    if errors:
        logger.error(f"SAML Authentication errors: {errors}")
        logger.error(f"Last error reason: {auth.get_last_error_reason()}")
        return f'Authentication failed: {", ".join(errors)}', 401
    
    if not auth.is_authenticated():
        logger.error("SAML Authentication failed: User not authenticated")
        return 'Authentication failed: Not authenticated', 401

    # Get user attributes
    attributes = auth.get_attributes()
    name_id = auth.get_nameid()
    logger.info(f"User authenticated. NameID: {name_id}")
    logger.info(f"User attributes: {attributes}")

    # Store user information in session
    session['samlUserdata'] = attributes
    session['samlNameId'] = name_id
    session['user'] = {
        'preferred_username': name_id,
        'name': attributes.get('displayName', [name_id])[0] if attributes else name_id
    }

    # Redirect to the next URL or admin page
    if 'next_url' in session:
        next_url = session.pop('next_url')
        logger.info(f"Redirecting to: {next_url}")
        return redirect(next_url)
    return redirect(url_for('admin'))

@app.route('/sso/sls')
def sls():
    req = prepare_flask_request(request)
    auth = init_saml_auth(req)
    url = auth.process_slo(delete_session_cb=lambda: session.clear())
    errors = auth.get_errors()
    if len(errors) == 0:
        if url is not None:
            return redirect(url)
        return redirect(url_for('admin'))
    return 'Logout failed', 500

@app.route('/sso/logout')
def logout():
    req = prepare_flask_request(request)
    auth = init_saml_auth(req)
    name_id = session.get('samlNameId')
    session_index = session.get('samlSessionIndex')
    if name_id is None and session_index is None:
        session.clear()
        return redirect(url_for('admin'))
    else:
        return redirect(auth.logout())

@app.route('/admin')
@requires_auth
def admin():
    page = request.args.get("page", 1, type=int)
    per_page = 50
    offset = (page - 1) * per_page
    
    conn = get_db()
    c = conn.cursor()
    
    # Get total count
    c.execute("SELECT COUNT(*) as count FROM links")
    total_links = c.fetchone()["count"]
    total_pages = (total_links + per_page - 1) // per_page
    
    # Get paginated links
    c.execute("""
        SELECT l.*, 
               COUNT(DISTINCT c.ip_address) as unique_visitors,
               COUNT(c.id) as total_clicks
        FROM links l
        LEFT JOIN clicks c ON l.short_link = c.short_link
        GROUP BY l.short_link
        ORDER BY l.created_at DESC
        LIMIT ? OFFSET ?
    """, (per_page, offset))
    
    links = c.fetchall()
    return render_template("admin.html", 
                         links=links,
                         user=session.get("user"),
                         page=page,
                         total_pages=total_pages,
                         total_links=total_links)

@app.route('/admin/search')
@requires_auth
def search_links():
    search_term = request.args.get("q", "").strip()
    page = request.args.get("page", 1, type=int)
    per_page = 50
    offset = (page - 1) * per_page
    
    logger.info(f"Searching for: {search_term} (page {page})")
    
    conn = get_db()
    c = conn.cursor()
    
    if search_term:
        search_pattern = f"%{search_term}%"
        # Get total count for search
        c.execute("""
            SELECT COUNT(*) as count 
            FROM links 
            WHERE short_link LIKE ? 
               OR target_url LIKE ? 
               OR filename LIKE ?
               OR description LIKE ?
        """, (search_pattern, search_pattern, search_pattern, search_pattern))
        total_links = c.fetchone()["count"]
        
        # Get paginated search results
        c.execute("""
            SELECT l.*, 
                   COUNT(DISTINCT c.ip_address) as unique_visitors,
                   COUNT(c.id) as total_clicks
            FROM links l
            LEFT JOIN clicks c ON l.short_link = c.short_link
            WHERE l.short_link LIKE ? 
               OR l.target_url LIKE ? 
               OR l.filename LIKE ?
               OR l.description LIKE ?
            GROUP BY l.short_link
            ORDER BY l.created_at DESC
            LIMIT ? OFFSET ?
        """, (search_pattern, search_pattern, search_pattern, search_pattern, per_page, offset))
    else:
        # Get total count
        c.execute("SELECT COUNT(*) as count FROM links")
        total_links = c.fetchone()["count"]
        
        # Get paginated results
        c.execute("""
            SELECT l.*, 
                   COUNT(DISTINCT c.ip_address) as unique_visitors,
                   COUNT(c.id) as total_clicks
            FROM links l
            LEFT JOIN clicks c ON l.short_link = c.short_link
            GROUP BY l.short_link
            ORDER BY l.created_at DESC
            LIMIT ? OFFSET ?
        """, (per_page, offset))
    
    total_pages = (total_links + per_page - 1) // per_page
    links = c.fetchall()
    logger.info(f"Found {total_links} results, showing page {page} of {total_pages}")
    return render_template("_links_table.html",
                         links=links,
                         page=page,
                         total_pages=total_pages,
                         total_links=total_links)

@app.route('/admin/create', methods=['POST'])
@requires_auth
def create_link():
    short_link = request.form['short_link']
    target_url = request.form['target_url']
    description = request.form.get('description', '')
    
    if short_link == 'admin':
        return 'Cannot use reserved word "admin"', 400
    
    conn = get_db()
    c = conn.cursor()
    c.execute('''
        INSERT OR REPLACE INTO links 
        (short_link, target_url, is_file, created_by, description) 
        VALUES (?, ?, 0, ?, ?)
    ''', (short_link, target_url, session['user'].get('preferred_username'), description))
    conn.commit()
    return redirect('/admin')

@app.route('/admin/upload', methods=['POST'])
@requires_auth
def upload_file():
    if 'file' not in request.files:
        return 'No file part', 400
    file = request.files['file']
    short_link = request.form['short_link']
    description = request.form.get('description', '')
    
    if short_link == 'admin':
        return 'Cannot use reserved word "admin"', 400
    
    if file.filename == '':
        return 'No selected file', 400
        
    if file:
        filename = secure_filename(file.filename)
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], 
                                short_link + '_' + filename)
        file.save(file_path)
        
        conn = get_db()
        c = conn.cursor()
        c.execute('''
            INSERT OR REPLACE INTO links 
            (short_link, target_url, is_file, filename, created_by, description) 
            VALUES (?, ?, 1, ?, ?, ?)
        ''', (short_link, file_path, filename, 
              session['user'].get('preferred_username'), description))
        conn.commit()
        
    return redirect('/admin')

@app.route('/admin/edit/<short_link>', methods=['GET', 'POST'])
@requires_auth
def edit_link(short_link):
    conn = get_db()
    c = conn.cursor()
    
    if request.method == 'GET':
        c.execute("SELECT * FROM links WHERE short_link = ?", (short_link,))
        link = c.fetchone()
        
        if link is None:
            abort(404)
            
        return render_template("edit.html", link=link)
    
    else:  # POST
        # Get current link info
        c.execute("SELECT * FROM links WHERE short_link = ?", (short_link,))
        current_link = c.fetchone()
        
        if current_link is None:
            abort(404)
        
        new_short_link = request.form["short_link"]
        description = request.form.get("description", "")
        
        if new_short_link == "admin":
            return "Cannot use reserved word \"admin\"", 400
        
        if current_link["is_file"]:
            file = request.files.get("file")
            if file and file.filename:
                # Delete old file
                try:
                    os.remove(current_link["target_url"])
                except OSError:
                    pass
                
                # Save new file
                filename = secure_filename(file.filename)
                file_path = os.path.join(app.config["UPLOAD_FOLDER"], 
                                    new_short_link + "_" + filename)
                file.save(file_path)
                
                # Update database
                if short_link == new_short_link:
                    c.execute("""
                        UPDATE links 
                        SET target_url = ?, filename = ?, description = ?
                        WHERE short_link = ?
                    """, (file_path, filename, description, short_link))
                else:
                    c.execute("""
                        INSERT OR REPLACE INTO links 
                        (short_link, target_url, is_file, filename, created_by, description)
                        VALUES (?, ?, 1, ?, ?, ?)
                    """, (new_short_link, file_path, filename,
                          session["user"].get("preferred_username"), description))
                    c.execute("DELETE FROM links WHERE short_link = ?", (short_link,))
            else:
                # Just update description and short_link
                if short_link == new_short_link:
                    c.execute("""
                        UPDATE links SET description = ? WHERE short_link = ?
                    """, (description, short_link))
                else:
                    c.execute("""
                        INSERT OR REPLACE INTO links 
                        (short_link, target_url, is_file, filename, created_by, description)
                        VALUES (?, ?, 1, ?, ?, ?)
                    """, (new_short_link, current_link["target_url"],
                          current_link["filename"],
                          session["user"].get("preferred_username"), description))
                    c.execute("DELETE FROM links WHERE short_link = ?", (short_link,))
        else:
            target_url = request.form["target_url"]
            if short_link == new_short_link:
                c.execute("""
                    UPDATE links 
                    SET target_url = ?, description = ?
                    WHERE short_link = ?
                """, (target_url, description, short_link))
            else:
                c.execute("""
                    INSERT OR REPLACE INTO links 
                    (short_link, target_url, is_file, created_by, description)
                    VALUES (?, ?, 0, ?, ?)
                """, (new_short_link, target_url,
                      session["user"].get("preferred_username"), description))
                c.execute("DELETE FROM links WHERE short_link = ?", (short_link,))
        
        conn.commit()
        return redirect("/admin")

@app.route('/admin/stats/<short_link>')
@requires_auth
def link_stats(short_link):
    stats = get_link_stats(short_link)
    return render_template('stats.html', short_link=short_link, stats=stats)

@app.route('/<short_link>')
def redirect_link(short_link):
    if short_link == 'admin':
        return redirect('/admin')
        
    conn = get_db()
    c = conn.cursor()
    c.execute('''
        SELECT target_url, is_file, filename 
        FROM links 
        WHERE short_link = ?
    ''', (short_link,))
    result = c.fetchone()
    
    if result is None:
        abort(404)
    
    # Record the click
    record_click(
        short_link=short_link,
        ip_address=request.remote_addr,
        user_agent=request.user_agent.string,
        referer=request.referrer
    )
        
    if result['is_file']:  # If it's a file
        return send_file(result['target_url'], 
                        download_name=result['filename'])
    else:  # If it's a URL
        return redirect(result['target_url'])

@app.route('/admin/delete', methods=['POST'])
@requires_auth
def delete_link():
    short_link = request.form['short_link']
    
    conn = get_db()
    c = conn.cursor()
    
    # Get file info before deletion
    c.execute('SELECT is_file, target_url FROM links WHERE short_link = ?', 
              (short_link,))
    result = c.fetchone()
    
    if result and result['is_file']:
        # Delete the file if it exists
        try:
            os.remove(result['target_url'])
        except OSError:
            pass
    
    # Delete from database
    c.execute('DELETE FROM links WHERE short_link = ?', (short_link,))
    conn.commit()
    
    return redirect('/admin')

@app.teardown_appcontext
def cleanup(exc):
    if hasattr(g, "db"):
        g.db.close()

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8081)from functools import wraps
from flask import session, redirect, url_for, current_app, request, g
from onelogin.saml2.auth import OneLogin_Saml2_Auth
from onelogin.saml2.utils import OneLogin_Saml2_Utils
import json
import os
from urllib.parse import urlparse
import logging

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

def init_saml_auth(req):
    saml_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'saml')
    with open(os.path.join(saml_path, 'settings.json'), 'r') as f:
        settings = json.load(f)
        logger.debug(f"SAML Settings loaded: {json.dumps(settings, indent=2)}")
    auth = OneLogin_Saml2_Auth(req, settings)
    return auth

def prepare_flask_request(request):
    url_data = urlparse(request.url)
    logger.debug(f"Preparing Flask request: URL={request.url}, Host={request.host}")
    
    # Get the actual URL scheme (http or https)
    scheme = request.headers.get('X-Forwarded-Proto', request.scheme)
    
    return {
        'https': 'on' if scheme == 'https' else 'off',
        'http_host': request.host,
        'server_port': url_data.port or (443 if scheme == 'https' else 80),
        'script_name': request.path,
        'get_data': request.args.copy(),
        'post_data': request.form.copy(),
        'query_string': request.query_string
    }

def requires_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if not current_app.config['ENABLE_SSO']:
            if 'user' not in session:
                session['user'] = {
                    'preferred_username': 'local_user',
                    'name': 'Local User'
                }
            return f(*args, **kwargs)
            
        if not session.get('user'):
            session['next_url'] = request.url
            logger.debug(f"No user in session, redirecting to SSO login. Next URL: {request.url}")
            return redirect(url_for('sso_login'))
            
        return f(*args, **kwargs)
    return decoratedimport os
from dotenv import load_dotenv

load_dotenv()

class Config:
    # Flask config
    SECRET_KEY = os.getenv('SECRET_KEY', 'your-secret-key')
    DEBUG = os.getenv('FLASK_DEBUG', 'false').lower() == 'true'
    
    # Database paths
    DATABASE_PATH = 'shortener.db'
    
    # Upload config
    UPLOAD_FOLDER = 'uploads'
    MAX_CONTENT_LENGTH = 500 * 1024 * 1024  # 500MB
    
    # Feature flags
    ENABLE_SSO = os.getenv('ENABLE_SSO', 'false').lower() == 'true'
    
    # Session config
    SESSION_TYPE = "filesystem"import sqlite3
from flask import current_app, g
import os

def get_db():
    if 'db' not in g:
        g.db = sqlite3.connect(current_app.config['DATABASE_PATH'])
        g.db.row_factory = sqlite3.Row
    return g.db

def close_db(e=None):
    db = g.pop('db', None)
    if db is not None:
        db.close()

def init_db():
    db = get_db()
    
    # Read schema
    with current_app.open_resource('schema.sql') as f:
        db.executescript(f.read().decode('utf8'))
    
    # Create uploads directory if it doesn't exist
    os.makedirs(current_app.config['UPLOAD_FOLDER'], exist_ok=True)

def record_click(short_link, ip_address, user_agent=None, referer=None):
    db = get_db()
    db.execute('''
        INSERT INTO clicks (short_link, ip_address, user_agent, referer)
        VALUES (?, ?, ?, ?)
    ''', (short_link, ip_address, user_agent, referer))
    db.commit()

def get_link_stats(short_link):
    db = get_db()
    # Get total clicks
    total_clicks = db.execute('''
        SELECT COUNT(*) as count FROM clicks WHERE short_link = ?
    ''', (short_link,)).fetchone()['count']
    
    # Get unique IPs
    unique_ips = db.execute('''
        SELECT COUNT(DISTINCT ip_address) as count FROM clicks WHERE short_link = ?
    ''', (short_link,)).fetchone()['count']
    
    # Get recent clicks
    recent_clicks = db.execute('''
        SELECT ip_address, user_agent, referer, clicked_at
        FROM clicks
        WHERE short_link = ?
        ORDER BY clicked_at DESC
        LIMIT 10
    ''', (short_link,)).fetchall()
    
    return {
        'total_clicks': total_clicks,
        'unique_visitors': unique_ips,
        'recent_clicks': recent_clicks
    }